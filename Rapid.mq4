//+------------------------------------------------------------------+
//|                                                        Rapid.mq4 |
//|                                                          Ryan Xu |
//|                                                                  |
//+------------------------------------------------------------------+
#property strict

#define MAGICMA 20000913

extern double      risk=0.02;
extern double      maxBalance = 0;
extern double      slatrScale=1;

datetime LastTimeBar=0;

int ticket = -1;
string symbol = NULL;
double unit_pip = 0;
double minLot = 0.01;
double maxLot = 1.00;
double stepLot = 0.01;
double lastLow = -1;
double lastHigh = -1;
int state = -1;
int sl_pips = 20; //Temporary Value, this is based off of ATR

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit() {
	//Grab Prelim Info
   symbol = Symbol();
   minLot = MarketInfo(symbol, MODE_MINLOT);
   maxLot = MarketInfo(symbol, MODE_MAXLOT);
   stepLot = MarketInfo(symbol, MODE_LOTSTEP);
   unit_pip = MathPow(0.1,Digits-1);
   //Check if there is an existing ticket for the symbol
   for(int i=0;i<OrdersTotal();i++){
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==false){
         continue;
      }
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==MAGICMA && OrderCloseTime()==0){
         ticket=OrderTicket();
      }
   }
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {

}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick() {
	if(iTime(Symbol(),0,0)!=LastTimeBar){
		LastTimeBar=iTime(symbol,0,0);
      ticket = -1;
      
      //Check if there is an existing ticket for the symbol
      for(int i=0;i<OrdersTotal();i++){
         if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==false){
            continue;
         }
         if(OrderSymbol()==Symbol() && OrderMagicNumber()==MAGICMA && OrderCloseTime()==0){
            ticket=OrderTicket();
         }
      }
	
		if(ticket==-1){ 
         EntryAnalysis();
      }else{
         ExitAnalysis();
      }
	}   
}

void EntryAnalysis(){
	//Gather Signals
	int kumoCloudTrend = KumoCloudTrend(symbol, PERIOD_CURRENT, 0);
	double kenkanShortTermMomentum = KenkanShortTermMomentum(symbol, PERIOD_CURRENT, 0);
	double kijunMediumTermMomentum = KijunMediumTermMomentum(symbol, PERIOD_CURRENT, 0);
	int kenkanKijunCross = KenkanKijunCross(symbol, PERIOD_CURRENT, 0);
	int chikouSpanConfirmation = ChikouSpanConfirmation(symbol, PERIOD_CURRENT, 0);
	double kumoCloud = KumoCloud(symbol, PERIOD_CURRENT, 0);
	sl_pips = ATRStop(symbol, PERIOD_CURRENT, 20, slatrScale) * MathPow(10, Digits-1);
	
	//Signal
	if(kumoCloudTrend == OP_BUY && kenkanKijunCross == OP_BUY){
		//Momentum analysis:
		if(kijunMediumTermMomentum > 0 && kenkanShortTermMomentum > 0){
			//Lagging Span Check:
			if(chikouSpanConfirmation > 0){
				double lot_size = lotSizeCalculator();
				if(lot_size > 0){
					RefreshRates();
         		ticket=OrderSend(symbol, OP_BUY, lot_size, NormalizeDouble(Ask, Digits), 10*unit_pip, Ask-sl_pips*unit_pip, 0, "Generated by Xurya Bot!",MAGICMA,0,clrLightGreen);
				}
			}
		}
	}
	
	//Signal
	if(kumoCloudTrend == OP_SELL && kenkanKijunCross == OP_BUY){
		//Momentum analysis:
		if(kijunMediumTermMomentum < 0 && kenkanShortTermMomentum < 0){
			//Lagging Span Check:
			if(chikouSpanConfirmation < 0){
				double lot_size = lotSizeCalculator();
				if(lot_size > 0){
					RefreshRates();
         		ticket=OrderSend(symbol, OP_SELL, lot_size, NormalizeDouble(Bid, Digits), 10*unit_pip, Bid+sl_pips*unit_pip, 0, "Generated by Xurya Bot!",MAGICMA,0,clrPurple); 
         	}
			}
		}
	}
}

void ExitAnalysis(){
	int chikouSpanConfirmation = ChikouSpanConfirmation(symbol, PERIOD_CURRENT, 0);

	//Buy
	if(ticket!=-1 && OrderSelect(ticket, SELECT_BY_TICKET) && OrderType() == OP_BUY && OrderCloseTime() == 0 ){
		if(chikouSpanConfirmation <= 0){
			OrderClose(ticket, OrderLots(), NormalizeDouble(Bid, Digits), 10*unit_pip, clrRed);
         ticket == -1;
         EntryAnalysis();
         return;
		}
	}
	
	//Sell
   if(ticket!=-1 && OrderSelect(ticket, SELECT_BY_TICKET) && OrderType() == OP_SELL && OrderCloseTime() == 0 ){
   	if(chikouSpanConfirmation >= 0){
   		OrderClose(ticket, OrderLots(), NormalizeDouble(Ask, Digits), 10*unit_pip, clrRed);
			ticket == -1;
         EntryAnalysis();
         return;
      }   
   }
} 

double lotSizeCalculator(){
	double balance = AccountBalance();
   if(maxBalance > 0){
      balance = MathMin(balance, maxBalance);
   }
   //step lot used instead of MinLot since Oanda is a weird broker...
   double lot_size = NormalizeDouble(MathMin(MathMax((risk*balance/sl_pips)/dblPipValue(symbol), stepLot), maxLot),2);
   int steps = lot_size / stepLot;
   lot_size = MathMax(stepLot, steps * stepLot); 
   
   //Check if we have money in the account
   if(AccountFreeMargin()<(1000*lot_size)){
      if(AccountFreeMargin()<(1000*minLot)){
         Print("Switching to MinLot");
         lot_size = minLot;
         return lot_size;
      }else{
      	return -1;
      }
   }
   
   return lot_size;
}